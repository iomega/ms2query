<!DOCTYPE html>
<meta charset="utf-8">
</head>
<body>

<h1>Link thresholds</h1>
<p>(Drag the slider to change the thresholds for forming a link)</p>

<div class="slidecontainer">
  <input type="range" min="0" max="100" value="50" id="TanimotoThreshold">
  <p>Tanimoto threshold: <span id="threshold"></span></p>
</div>
<div class="slidecontainer">
  <input type="range" min="0" max="100" value="50" id="S2VThreshold">
  <p>Spec2Vec threshold: <span id="s2v_threshold"></span></p>
</div>


<svg width="960" height="600"></svg>

<script src="https://d3js.org/d3.v4.min.js"></script>
<script>
const padding = 20

var slider = document.getElementById("TanimotoThreshold");
var output = document.getElementById("threshold");
output.innerHTML = slider.value / 100;

var slider_s2v = document.getElementById("S2VThreshold");
var output_s2v = document.getElementById("s2v_threshold");
output_s2v.innerHTML = slider_s2v.value / 100;

slider.oninput = function() {
  output.innerHTML = this.value / 100;
  links = baseLinks.filter(linkAboveThres)
  updateGraph()
  updateSimulation()
}

slider_s2v.oninput = function() {
  output_s2v.innerHTML = this.value / 100;
  links = baseLinks.filter(linkAboveThres)
  updateGraph()
  updateSimulation()
}

function linkAboveThres(link) {
  if (link.type == "s2v") {
    return (link.strength > output_s2v.innerHTML)
  } else if (link.type == "tanimoto") {
    return (link.strength > output.innerHTML)
  }
}

var baseNodes = [
  { id: 0, type: 0, label: "Query", level: 1 },
  { id: 1 , type: 1, label: "Cand1"   , level: 2 },
  { id: 2 , type: 1, label: "Cand2"   , level: 2 },
  { id: 3 , type: 1, label: "Cand3"  , level: 2 },
  { id: 4 , type: 1, label: "Cand4"    , level: 2 },
  { id: 5, type: 1, label: "Cand5", level: 1 },
  { id: 6 , type: 1, label: "Cand6"   , level: 2 },
  { id: 7 , type: 1, label: "Cand7"   , level: 2 },
  { id: 8 , type: 1, label: "Cand8"   , level: 1 },
  { id: 9 , type: 1, label: "Cand9"   , level: 2 },
  { id: 10 , type: 1, label: "Cand10"  , level: 2 }
]

var baseLinks = [
	{ target: 0, source: 1, strength: 0.7, type: "s2v" },
	{ target: 0, source: 2, strength: 0.9, type: "s2v" },
  { target: 0, source: 3, strength: 0.7, type: "s2v" },
  { target: 0, source: 4, strength: 0.8, type: "s2v" },
  { target: 0, source: 5, strength: 0.7, type: "s2v" },
  { target: 0, source: 6, strength: 0.5, type: "s2v" },
  { target: 0, source: 7, strength: 0.4, type: "s2v" },
  { target: 0, source: 8, strength: 0.25, type: "s2v" },
  { target: 0, source: 9, strength: 0.2, type: "s2v" },
  { target: 0, source: 10, strength: 0.1, type: "s2v" },
  { target: 1, source: 2, strength: 0.7, type: "tanimoto"  },
  { target: 1, source: 7, strength: 0.15, type: "tanimoto"  },
  { target: 2, source: 3, strength: 0.35, type: "tanimoto"  },
  { target: 1, source: 3, strength: 0.6, type: "tanimoto"  },
  { target: 4, source: 5, strength: 0.2, type: "tanimoto"  },
  { target: 6, source: 9, strength: 0.3, type: "tanimoto"  },
  { target: 5, source: 10, strength: 0.1, type: "tanimoto"  },
  { target: 3, source: 7, strength: 0.3, type: "tanimoto"  },
]

var nodes = [...baseNodes]
var links = [...baseLinks]

function getNeighbors(node) {
  return baseLinks.reduce(function (neighbors, link) {
      if (link.target.id === node.id) {
        neighbors.push(link.source.id)
      } else if (link.source.id === node.id) {
        neighbors.push(link.target.id)
      }
      return neighbors
    },
    [node.id]
  )
}

function isNeighborLink(node, link) {
  return link.target.id === node.id || link.source.id === node.id
}


function getNodeColor(node) {
  return node.type === 0 ? 'Crimson' : 'CornflowerBlue'
}

function getEdgeStyle(link) {
  return link.type == "tanimoto" ? ("3, 3") : ("3, 0")
}

function getEdgeColor(link) {
  return link.type == "tanimoto" ? 'rgba(50, 50, 50, 0.4)' : 'rgba(200, 20, 20, 0.4)'
}

function getLinkStrength(link) {
  if (link.type === "tanimoto") {
    return link.strength / 50
  }  else if (link.type === "s2v") {
    return link.strength / 80
  }
}


var width = window.innerWidth
var height = window.innerHeight

var svg = d3.select('svg')
svg.attr('width', width).attr('height', height)

var linkElements,
  nodeElements,
  textElements

// we use svg groups to logically group the elements together
var linkGroup = svg.append('g').attr('class', 'links')
var nodeGroup = svg.append('g').attr('class', 'nodes')
var textGroup = svg.append('g').attr('class', 'texts')

// we use this reference to select/deselect
// after clicking the same element twice
var selectedId

// simulation setup with all forces
var linkForce = d3
  .forceLink()
  .id(function (link) { return link.id })
  .strength(getLinkStrength)

var simulation = d3
  .forceSimulation()
  .force('link', linkForce)
  .force('charge', d3.forceManyBody())
  .force('center', d3.forceCenter(width / 2, height / 2))
  .force("collide",d3.forceCollide( function(node){return node.level + 8 }).iterations(16) )
  .velocityDecay(0.1)
  .alphaTarget(0.4);

var dragDrop = d3.drag().on('start', function (node) {
  node.fx = node.x
  node.fy = node.y
}).on('drag', function (node) {
  simulation.alphaTarget(0.7).restart()
  node.fx = d3.event.x
  node.fy = d3.event.y
}).on('end', function (node) {
  if (!d3.event.active) {
    simulation.alphaTarget(0)
  }
  node.fx = null
  node.fy = null
})

// select node is called on every click
// we either update the data according to the selection
// or reset the data if the same node is clicked twice
function selectNode(selectedNode) {
    updateSimulation()
}

// this helper simple adds all nodes and links
// that are missing, to recreate the initial state
function resetData() {
  var nodeIds = nodes.map(function (node) { return node.id })

  baseNodes.forEach(function (node) {
    if (nodeIds.indexOf(node.id) === -1) {
      nodes.push(node)
    }
  })

  links = baseLinks
}

// diffing and mutating the data
function updateData(selectedNode) {
  var neighbors = getNeighbors(selectedNode)
  var newNodes = baseNodes.filter(function (node) {
    return neighbors.indexOf(node.id) > -1 || node.level === 1
  })

  var diff = {
    removed: nodes.filter(function (node) { return newNodes.indexOf(node) === -1 }),
    added: newNodes.filter(function (node) { return nodes.indexOf(node) === -1 })
  }

  diff.removed.forEach(function (node) { nodes.splice(nodes.indexOf(node), 1) })
  diff.added.forEach(function (node) { nodes.push(node) })

  links = baseLinks.filter(function (link) {
    return link.target.id === selectedNode.id || link.source.id === selectedNode.id
  })
}

function updateGraph() {
  // links
  linkElements = linkGroup.selectAll('line')
    .data(links, function (link) {
      return link.target.id + link.source.id
    })

  linkElements.exit().remove()

  var linkEnter = linkElements
    .enter().append('line')
    .attr('stroke-width', function (link) { return 0.5 + 10 * link.strength})
    .attr('stroke', getEdgeColor)
    .style("stroke-dasharray", getEdgeStyle)

  linkElements = linkEnter.merge(linkElements)

  // nodes
  nodeElements = nodeGroup.selectAll('circle')
    .data(nodes, function (node) { return node.id })

  nodeElements.exit().remove()

  var nodeEnter = nodeElements
    .enter()
    .append('circle')
    .attr("r", 15)
    .attr("fill", getNodeColor)
    .attr("stroke", "#fff")
    .attr("stroke-width", 2)
    .call(dragDrop)
    // we link the selectNode method here
    // to update the graph on every click
    .on('click', selectNode)

  nodeElements = nodeEnter.merge(nodeElements)

  // texts
  textElements = textGroup.selectAll('text')
    .data(nodes, function (node) { return node.id })

  textElements.exit().remove()

  var textEnter = textElements
    .enter()
    .append('text')
    .text(function (node) { return node.label })
    .attr('font-size', 15)
    .attr('dx', 15)
    .attr('dy', 4)

  textElements = textEnter.merge(textElements)
}

function nodex(node) {
  if (node.x < 0 + padding) {
    return 0 + padding
} else if (node.x > width - padding) {
  return width - padding
} else {
  return node.x
}}

function nodey(node) {
  if (node.y < 0 + padding) {
    return 0 + padding
} else if (node.y > height - padding) {
  return height - padding
} else {
  return node.y
}}

function updateSimulation() {
  updateGraph()

  simulation.nodes(nodes).on('tick', () => {
    nodeElements
      .attr('cx', nodex)
      .attr('cy', nodey)
    textElements
      .attr('x', nodex)
      .attr('y', nodey)
    linkElements
      .attr('x1', function (link) { return link.source.x })
      .attr('y1', function (link) { return link.source.y })
      .attr('x2', function (link) { return link.target.x })
      .attr('y2', function (link) { return link.target.y })
  })

  simulation.force('link').links(links)
  simulation.alphaTarget(0.7).restart()
}

// last but not least, we call updateSimulation
// to trigger the initial render
updateSimulation()

</script>
</body>
